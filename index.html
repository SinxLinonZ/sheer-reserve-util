<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>

        <script src="./echarts.min.js"></script>
        <script src="./jquery-3.6.0.min.js"></script>
    </head>
    <body>
        <div id="chart"></div>

        <script type="text/javascript">
            let myChart = echarts.init(document.getElementById("chart"), null, {
                width: window.innerWidth,
                height: 600,
            });

            let option = {
                series: [
                    {
                        type: "custom",
                        renderItem: function (params, api) {

                            
                            let y_date = api.value(0);
                            let startPoint = api.coord([
                                api.value(1),
                                y_date,
                            ]);
                            let endPoint = api.coord([
                                api.value(2),
                                y_date,
                            ]);
                            let height = api.size([0, 1])[1] * 0.6;

                            // shape 属性描述了这个矩形的像素位置和大小。
                            // 其中特殊得用到了 echarts.graphic.clipRectByRect，意思是，
                            // 如果矩形超出了当前坐标系的包围盒，则剪裁这个矩形。
                            // 如果矩形完全被剪掉，会返回 undefined.
                            let rectShape = echarts.graphic.clipRectByRect(
                                {
                                    // 矩形的位置和大小。
                                    x: startPoint[0],
                                    y: startPoint[1] - height / 2,
                                    width: endPoint[0] - startPoint[0],
                                    height: height,
                                },
                                {
                                    // 当前坐标系的包围盒。
                                    x: params.coordSys.x,
                                    y: params.coordSys.y,
                                    width: params.coordSys.width,
                                    height: params.coordSys.height,
                                }
                            );

                            console.log(startPoint, endPoint);

                            // 这里返回为这个 dataItem 构建的图形元素定义。
                            return (
                                rectShape && {
                                    // 表示这个图形元素是矩形。还可以是 'circle', 'sector', 'polygon' 等等。
                                    type: "rect",
                                    shape: rectShape,
                                    // 用 api.style(...) 得到默认的样式设置。这个样式设置包含了
                                    // option 中 itemStyle 的配置和视觉映射得到的颜色。
                                    style: api.style(),
                                }
                            );
                        },

                        encode: {
                            // data 中『维度1』和『维度2』对应到 X 轴
                            x: [1, 2],
                            // data 中『维度0』对应到 Y 轴
                            y: 0,
                        },

                        data: [
                            ["2021-01-01", -10 * 60 * 60 * 1000, 0, 60], // 这是第一个 dataItem
                            ["2021-01-02", -10 * 60 * 60 * 1000, 0, 60], // 这是第一个 dataItem
                            ["2021-01-03", -10 * 60 * 60 * 1000, 0, 60], // 这是第一个 dataItem
                        ],
                    },
                ],

                title: {
                    text: "Sheer预约可视化",
                },
                xAxis: {
                    type: "time",
                    name: "时间",
                },
                yAxis: {
                    type: "category",
                    name: "日期",
                },
            };

            myChart.setOption(option);
        </script>
    </body>
</html>
